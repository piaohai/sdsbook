## 背景

编程是一门科学，但往往会乔装成一门艺术。我们从不去了解软件最底层的机理，或者说根本没有人在乎这些。软件并不只是算法、数据结构、编程语言、或者抽象云云，这些不过是一些工具而已，被我们创造、使用、最后抛弃。软件真正的本质，其实是人的本质。

举例来说，当我们遇到一个高度复杂的问题时，我们会群策群力，分工合作，将问题拆分为若干个部分，一起解决。这里就体现了编程的科学：创建一组小型的构建模块，让人们易于理解和使用，那么大家就会一起用它来解决问题。

我们生活在一个普遍联系的世界里，需要现代的编程软件为我们做指引。所以，未来我们所需要的用于处理大规模计算的构建模块，必须是普遍联系的，而且能够并行运作。那时，程序代码不能再只关注自己，它们需要互相交流，变得足够健谈。程序代码需要像人脑一样，数以兆计的神经元高速地传输信号，在一个没有中央控制的环境下，没有单点故障的环境下，解决问题。这一点其实并不意外，因为就当今的网络来讲，每个节点其实就像是连接了一个人脑一样。

如果你曾和线程、协议、或网络打过交道，你会觉得我上面的话像是天方夜谭。因为在实际应用过程中，只是连接几个程序或网络就已经非常困难和麻烦了。数以兆计的节点？那真是无法想象的。现今只有资金雄厚的企业才能负担得起这种软件和服务。

当今世界的网络结构已经远远超越了我们自身的驾驭能力。十九世纪八十年代的软件危机，弗莱德•布鲁克斯曾说过，这个世上没有银弹。后来，免费和开源解决了这次软件危机，让我们能够高效地分享知识。如今，我们又面临一次新的软件危机，只不过我们谈论得不多。只有那些大型的、富足的企业才有财力建立高度联系的应用程序。那里有云的存在，但它是私有的。我们的数据和知识正在从我们的个人电脑中消失，流入云端，无法获得或与其竞争。是谁坐拥我们的社交网络？这真像一次巨型主机的革命。

我们暂且不谈其中的政治因素，光那些就可以另外出本书了。目前的现状是，虽然互联网能够让千万个程序相连，但我们之中的大多数却无法做到这些。这样一来，那些真正有趣的大型问题（如健康、教育、经济、交通等领域），仍然无法解决。我们没有能力将代码连接起来，也就不能像大脑中的神经元一样处理那些大规模的问题。

已经有人尝试用各种方法来连接应用程序，如数以千计的IETF规范，每种规范解决一个特定问题。对于开发人员来说，HTTP协议是比较简单和易用的，但这也往往让问题变得更糟，因为它鼓励人们形成一种重服务端、轻客户端的思想。

所以迄今为止人们还在使用原始的TCP/UDP协议、私有协议、HTTP协议、网络套接字等形式连接应用程序。这种做法依旧让人痛苦，速度慢又不易扩展，需要集中化管理。而分布式的P2P协议又仅仅适用于娱乐，而非真正的应用。有谁会使用Skype或者Bittorrent来交换数据呢？

这就让我们回归到编程科学的问题上来。想要拯救这个世界，我们需要做两件事情：

* 一，如何在任何地点连接任何两个应用程序；
* 二、将这个解决方案用最为简单的方式包装起来，供程序员使用。

## 为什么使用消息队列

由于上述遇到的问题，所以我们引入的消息队列，来解决对应遇到的困难。消息队列带来以下好处：

* **解耦**

  在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息队列在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。

* ** 冗余**

  有时在处理数据的时候处理过程会失败。除非数据被持久化，否则将永远丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。在被许多消息队列所采用的"插入-获取-删除"范式中，在把一个消息从队列中删除之前，需要你的处理过程明确的指出该消息已经被处理完毕，确保你的数据被安全的保存直到你使用完毕。

* **扩展性**

  因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的；只要另外增加处理过程即可。不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单。

* **灵活性 & 峰值处理能力**

  当你的应用上了Hacker News的首页，你将发现访问流量攀升到一个不同寻常的水平。在访问量剧增的情况下，你的应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住增长的访问压力，而不是因为超出负荷的请求而完全崩溃。请查看我们[关于峰值处理能力的博客文章](http://blog.iron.io/2012/06/spikability-applications-ability-to.html)了解更多此方面的信息。

* **可恢复性**

  当体系的一部分组件失效，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。而这种允许重试或者延后处理请求的能力通常是造就一个略感不便的用户和一个沮丧透顶的用户之间的区别。

* **送达保证**

  消息队列提供的冗余机制保证了消息能被实际的处理，只要一个进程读取了该队列即可。在此基础上，IronMQ提供了一个"只送达一次"保证。无论有多少进程在从队列中领取数据，每一个消息只能被处理一次。这之所以成为可能，是因为获取一个消息只是"预定"了这个消息，暂时把它移出了队列。除非客户端明确的表示已经处理完了这个消息，否则这个消息会被放回队列中去，在一段可配置的时间之后可再次被处理。

* **排序保证**

  在许多情况下，数据处理的顺序都很重要。消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。IronMO保证消息浆糊通过FIFO（先进先出）的顺序来处理，因此消息在队列中的位置就是从队列中检索他们的位置。

* **缓冲**

  在任何重要的系统中，都会有需要不同的处理时间的元素。例如,加载一张图片比应用过滤器花费更少的时间。消息队列通过一个缓冲层来帮助任务最高效率的执行--写入队列的处理会尽可能的快速，而不受从队列读的预备处理的约束。该缓冲有助于控制和优化数据流经过系统的速度。

* **理解数据流**

  在一个分布式系统里，要得到一个关于用户操作会用多长时间及其原因的总体印象，是个巨大的挑战。消息系列通过消息被处理的频率，来方便的辅助确定那些表现不佳的处理过程或领域，这些地方的数据流都不够优化。

* **异步通信**

  很多时候，你不想也不需要立即处理消息。消息队列提供了异步处理机制，允许你把一个消息放入队列，但并不立即处理它。你想向队列中放入多少消息就放多少，然后在你乐意的时候再去处理它们。

## 主流的消息中间件

目前，开源的消息中间件类型很多，主要会被使用到的有以下几种：

* **RabbitMQ**

  RabbitMQ 是基于 AMQP 协议一个一种主流的实现方式。它是一种基于代理的架构，有一系例中心的节点，所有消息都会从生产者发送至该中心节点，然后再从中心节点被分发至各个消费者。这种架构决定了 RabbitMQ 十分易用，并且易部署，关于数据路由，负载均衡，消息持久化等高级功能，都在 RabbitMQ 中被实现。用户只需要进行简单的配置，以及少量的代码，就可以达到预想的效果。但是，这些高级的特性增加了起复杂度，使得其在扩展性与性能上都做出了很大的牺牲。关于 RabbitMQ 使用，请参见：[RabbitMQ文档](https://www.rabbitmq.com/documentation.html)

* **ActiveMQ**

  ActiveMQ 是 Apache 下面的一个开源项目，是一种较流行的 Message Queue。它提供了一些高级特性，如：消息组，虚拟目的地，地址通配等。并且可以和 Java EE，ESBs 和 其他的 JMS 供应商无缝集成。在 AcitveMQ 中，ActiveMQ Apollo 是一个与 RabbitMQ 类似的中心代理，它在其内部实现了多线程的消息分发，并且支持多种代理协议，包括 STOMP，AMQP，MQTT，Openwire，SSL 与 WebSockets，相对于 RabbitMQ 来说，用户可以根据业务使用的不同协议进行适配。关于 ActiveMQ 使用，请参见：[ActiveMQ文档](http://activemq.apache.org/getting-started.html)

* **ZeroMQ\***

  ZeroMQ 相对于 RabbitMQ 与 ActiveMQ 来说，是一个轻量级的消息队列系统。它能够提供极高的吞吐和极低的消息分发延时，主要用于金融领域，相比于 RabbitMQ 和 ActiveMQ，在性能上有5～10倍的提升。但是这种性能的提升是要付出代价的，ZeroMQ 不为用户实现任何的消息路由，消息持久话，复杂均衡等高级功能，只提供底层最基本的 API 调用，而所有的这些功能都需要用户根据业务场景自行去实现，或者决定实现那些特性。所以 ZeroMQ 往往更加灵活和高效，这类似于 C++ 与 Java 的内存管理处理机制。关于 ZeroMQ 的使用，请参见：[ZeroMQ文档](https://github.com/anjuke/zguide-cn/)

* **Kafka**

  Kafka 严格来说不应该归类为消息队列的类别，它是一个能提供高吞吐的大规模分布式系统，但也有这类似的功能。Kafka 能够通过 Zookeeper 来处理单点故障，自动切换。生产者只需要把消息推进 Kafka，消息会自动分片到一个节点上进行处理，并且持久化。由于 Kafka 是为大规模分布式系统设计的，消息分发的实时性相比于上面 RabbitMQ 于 ActiveMQ 差很多，更不用说 ZeroMQ 了。Kafka 的设计目标是高吞吐，而并非高实时性，故通常用于大数据处理领域（如：实时的海量日志分析，实时的交易日志分析等）。关于 Kafka 的使用，请参见：[Kafka文档](https://kafka.apache.org/documentation/)

类比图：gfd

![](/assets/xiaoxizhongjianjian_1.png)

![](/assets/xiaoxizhongjianjian_2.png)

