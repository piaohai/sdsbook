## 背景

在文档型NoSQL数据库出现之前，许多开发者一直绞尽脑汁思考，希望能想出更好的处理关系型数据库技术的方法，如今他们可能要跳出那种思维而另辟蹊径。

人们通常都不愿意改变，因为改变总是痛苦的，除非它能显著解决一些问题。随着大数据的发展，我们越来越有必要开始对数据模型做出转变了。换句话说，这种转变的需求愈发的强烈，因为大数据时代不管是对于数据库的扩展模型还是数据模型都要求极高的灵活性。

关系型数据库是一种“纵向扩展”的技术，想要扩展容量（无论数据存储还是I/O），都需要更换更大的服务器。现代应用结构的解决却是使用“横向扩展”----无需新购买更大的服务器，只需要在负载均衡器下增加一般的服务器、虚拟机或是云服务器就可以实现扩展。此外，容量在不再需要的时候还可以轻易的缩减。事实上，“横向扩展”在应用逻辑层的使用已经很广泛了，只是数据库技术上刚刚赶上而已。

NoSQL“横向扩展”部署方案的优点已经受到了业界的注意，但是同时很多人忽略的是NoSQL数据管理的简洁，不需要很复杂的操作模式构建，这一点对于数据库的提升也和扩展模型一样重要。在使用传统关系数据库时，添加数据前，需要定义操作模式。之后每一条记录的加入都需要严格的按照定义的操作模式进行，比如固定的列数和数据类型。因此，改变那些分区关系型数据库的操作模式，会非常的麻烦。如果你的数据获取和数据管理需求经常变化，那这种严格的模式限制将会成为制约表现的屏障。NoSQL（无论文档型、列式、K-V等等）都是水平扩展的，它们都不需要预先定义操作模式、所以也不需要在需求改变时改变操作模式。接下来我就将使用SequoiaDB来介绍文档型NoSQL数据库技术。

下图就对比了四条记录在关系型和文档型数据模型下的存储情况:

![](/assets/wendangxingshujuku_1.png)

如上所示，关系型数据库中的每一条记录存储都需要遵守一个固定的模式----固定的列数，每一列都是有特定的意义而且规定了数据类型。如果要获取不同的数据，数据库的模式就需要重新修改。此外，关系型模型还有一个特点就是“数据库标准化”，也就是大的表会被压缩成小的、整合的表，如下图所示：

![](/assets/wendangxingshujuku_2.png)

在上面的例子中，数据库用来存储错误日志信息。每个错误记录（表1中的一行）由3部分组成：错误号ERR，错误发生的时间TIME，和错误发生的数据中心DC。为了避免重复记录所有的错误记录的数据中心信息，现在每条错误记录将都指向表2（数据中心信息）中的对应的地点那一条记录。这样就不需要实际存储具体的DC信息在表1中，需要使用时只要到对应的表2行获取就可以了。在关系模型当中，多个表中的不同记录经常“交错连接”，一些数据会被多条记录共享。这样的好处就是减少了重复数据的出现，但是这样不好的地方就是一旦其中某一条链接的记录发生改变，那么与其相关的记录和表都会被锁住以防止非一致性的出现。 ACID事务在关系型数据库中是很复杂的，因为数据会扩散。即便是单一条记录，这复杂的共享数据内部关系网的存在，也使得关系型数据在多个服务器之间的传递变得复杂而缓慢，同时让读和写操作的性能变差。当存储空间昂贵又稀少时，折中的权衡方案是很必要的。然而，如今存储空间的价格跟40年前相比已经大大的下降了，很多时候计算折中方案已经完全没有必要。使用更多的存储空间来换取更好的操作性能，或者是将工作负载分配到多台机器上，这才是如今应用上更好的解决方案。

使用“文档”这个词似乎让人觉得奇怪，但是其实 “文档型数据模型”真的和传统意义的文字“文档”没有什么关系。他不是书、信或者文章，这里说的“文档”其实是一个数据记录，这个记录能够对包含的数据类型和内容进行“自我描述”。XML文档、HTML文档和JSON 文档就属于这一类。SequoiaDB就是使用JSON格式的文档型的数据库，它的存储的数据是这样的：

![](/assets/wendangxingshujuku_3.png)

可以看到，数据是不规则的，每一条记录包含了所有的有关“SequoiaDB”的信息而没有任何外部的引用，这条记录就是“自包含”的。这就使得记录很容易完全移动到其他服务器，因为这条记录的所有信息都包含在里面了，不需要考虑还有信息在别的表没有一起迁移走。同时，因为在移动过程中，只有被移动的那一条记录（文档）需要操作而不像关系型中每个有联系的表都需要锁住来保证一致性，这样一来ACID的保证就会变得更快速，读写的速度也会有很大的提升。

## MongoDB

MongoDB是一款非常常用的面向文档型非关系数据库，主要应用在微博、博客、IM等的消息存储业务中，由于存储的数据与金融等行业比起来并不是那么重要，而且对事务也没什么要求，所以在这种场景下，MongoDB要比关系型数据库更适合，因为传统的关系型数据库的每次操作都会有ACK，而MongoDB的设计去掉了这个步骤，大大提高了存储的性能，而且MongoDB的设计考虑了设备故障经常出现的场景，所以在设计时就做了容灾和故障转移方面方案。

当 MongoDB 复制集遇到下面的业务场景时，你就需要考虑使用 Sharded cluster，将数据分发到多个节点并发存储。

关于 MongoDB 副本分片，请参见：[MongoDB Sharded Cluster 架构原理](http://www.mongoing.com/archives/2782)

关于 MongoDB 使用与原理，请参见：MongoDB文档



